#version 450
#extension GL_EXT_nonuniform_qualifier : require

// Bindless layout (set 0):
// binding 1: storage images (HeadImage)
// binding 6: storage buffers (SelectionNodes, BoxSelectResult) via indices
layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PC {
    uvec2 BoxMin;
    uvec2 BoxMax;
    uint ObjectCount;
    uint HeadImageIndex;
    uint SelectionNodesIndex;
    uint BoxResultIndex;
} pc;

struct SelectionNode {
    uvec2 Pixel;
    float Depth;
    uint ObjectId;
    uint Next;
};

const uint INVALID_NODE = 0xffffffffu;

layout(set = 0, binding = 1, r32ui) uniform uimage2D HeadImages[];

layout(set = 0, binding = 6, std430) buffer SelectionNodes {
    SelectionNode Nodes[];
} SelectionBuffers[];

layout(set = 0, binding = 6, std430) buffer BoxSelectResult {
    uint Bits[];
} BoxResults[];

void main() {
    const uvec2 local = gl_GlobalInvocationID.xy;
    const uvec2 pixel = pc.BoxMin + local;
    if (pixel.x >= pc.BoxMax.x || pixel.y >= pc.BoxMax.y) return;

    uint idx = imageLoad(HeadImages[pc.HeadImageIndex], ivec2(pixel)).r;
    while (idx != INVALID_NODE) {
        const SelectionNode node = SelectionBuffers[pc.SelectionNodesIndex].Nodes[idx];
        if (node.ObjectId != 0 && node.ObjectId <= pc.ObjectCount) {
            const uint object_idx = node.ObjectId - 1;
            const uint word_idx = object_idx >> 5;
            const uint bit = object_idx & 31;
            atomicOr(BoxResults[pc.BoxResultIndex].Bits[word_idx], 1u << bit);
        }
        idx = node.Next;
    }
}
