#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

// Bindless layout (set 0):
// binding BINDING_Image: storage images (HeadImage)
// binding BINDING_Buffer: storage buffers (SelectionNodes, BoxSelectResult) via indices
layout(local_size_x = 16, local_size_y = 16) in;

#include "BoxSelectPushConstants.glsl"
#include "SelectionNode.glsl"

const uint INVALID_NODE = 0xffffffffu;

layout(set = 0, binding = BINDING_Image, r32ui) uniform uimage2D HeadImages[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer SelectionNodes {
    SelectionNode Nodes[];
} SelectionBuffers[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer BoxSelectResult {
    uint Bits[];
} BoxResults[];

// Mark an ID as selected in the result bitset (one bit per ID, packed into uint32 words).
// `>> 5` divides by 32 to find the word, `& 31` gives the bit position within that word.
void markSelected(uint id) {
    const uint bit_idx = id - 1;
    atomicOr(BoxResults[pc.BoxResultIndex].Bits[bit_idx >> 5], 1u << (bit_idx & 31));
}

void main() {
    const uvec2 local = gl_GlobalInvocationID.xy;
    const uvec2 pixel = pc.BoxMin + local;
    if (pixel.x >= pc.BoxMax.x || pixel.y >= pc.BoxMax.y) return;

    float min_depth = 1.0;
    uint min_id = 0u;
    uint idx = imageLoad(HeadImages[pc.HeadImageIndex], ivec2(pixel)).r;
    while (idx != INVALID_NODE) {
        const SelectionNode node = SelectionBuffers[pc.SelectionNodesIndex].Nodes[idx];
        if (node.Id != 0 && node.Id <= pc.MaxId) {
            if (node.Depth < min_depth) {
                min_depth = node.Depth;
                min_id = node.Id;
            }
            if (pc.XRay != 0u) markSelected(node.Id);
        }
        idx = node.Next;
    }
    if (pc.XRay == 0u && min_id != 0u) markSelected(min_id);
}
