#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#define GROUP_SIZE 256
layout(local_size_x = GROUP_SIZE) in;

#include "ObjectPickPushConstants.glsl"
#include "SelectionNode.glsl"

const uint INVALID_NODE = 0xffffffffu;

layout(set = 0, binding = BINDING_Image, r32ui) uniform uimage2D HeadImages[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer SelectionNodes {
    SelectionNode Nodes[];
} SelectionBuffers[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer ObjectBestKeys {
    uint Keys[];
} BestKeyBuffers[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer SeenObjectBits {
    uint Bits[];
} SeenBitsBuffers[];

uint PackKey(uint dist_sq, float depth) {
    const uint dist_u8 = min(dist_sq, 0xffu);
    const uint depth_u16 = uint(clamp(depth, 0.0, 1.0) * 65535.0 + 0.5);
    return (pc.EpochInv << 24u) | (dist_u8 << 16u) | depth_u16;
}

void main() {
    const uint local = gl_LocalInvocationID.x;
    const uint max_id = pc.MaxId;
    if (max_id == 0u) return;

    // Clear this click's seen-object bitset.
    const uint bit_words = (max_id + 31u) / 32u;
    for (uint i = local; i < bit_words; i += GROUP_SIZE) {
        atomicExchange(SeenBitsBuffers[pc.SeenBitsIndex].Bits[i], 0u);
    }
    barrier();

    const uint diameter = pc.Radius * 2u + 1u;
    const uint pixel_count = diameter * diameter;
    const ivec2 size = imageSize(HeadImages[pc.HeadImageIndex]);

    for (uint i = local; i < pixel_count; i += GROUP_SIZE) {
        const int dx = int(i % diameter) - int(pc.Radius);
        const int dy = int(i / diameter) - int(pc.Radius);
        const uint dist_sq = uint(dx * dx + dy * dy);
        if (dist_sq > pc.Radius * pc.Radius) continue;
        const ivec2 pixel = ivec2(pc.TargetPx) + ivec2(dx, dy);
        if (pixel.x < 0 || pixel.y < 0 || pixel.x >= size.x || pixel.y >= size.y) continue;

        uint node_idx = imageLoad(HeadImages[pc.HeadImageIndex], pixel).r;
        while (node_idx != INVALID_NODE) {
            const SelectionNode node = SelectionBuffers[pc.SelectionNodesIndex].Nodes[node_idx];
            if (node.Id > 0u && node.Id <= max_id) {
                const uint idx = node.Id - 1u;
                atomicMin(BestKeyBuffers[pc.BestKeyIndex].Keys[idx], PackKey(dist_sq, node.Depth));
                atomicOr(SeenBitsBuffers[pc.SeenBitsIndex].Bits[idx >> 5u], 1u << (idx & 31u));
            }
            node_idx = node.Next;
        }
    }
}
