#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

// Bindless layout (set 0):
// binding BINDING_Image: storage images (HeadImage)
// binding BINDING_Buffer: storage buffers (SelectionNodes, ClickResult) via indices
layout(local_size_x = 1) in;

#include "BindlessBindings.glsl"

layout(push_constant) uniform PC {
    uvec2 TargetPx;
    uint HeadImageIndex;
    uint SelectionNodesIndex;
    uint ClickResultIndex;
} pc;

struct SelectionNode {
    float Depth;
    uint ObjectId;
    uint Next;
};

#define MAX_CLICK_RESULTS 64
const uint INVALID_NODE = 0xffffffffu;

layout(set = 0, binding = BINDING_Image, r32ui) uniform uimage2D HeadImages[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer SelectionNodes {
    SelectionNode Nodes[];
} SelectionBuffers[];

struct ClickHit {
    float Depth;
    uint ObjectId;
};

layout(set = 0, binding = BINDING_Buffer, scalar) buffer ClickResult {
    uint Count;
    ClickHit Hits[MAX_CLICK_RESULTS];
} ClickResults[];

void main() {
    // Single invocation does the traversal
    if (gl_GlobalInvocationID.x != 0) return;

    uint idx = imageLoad(HeadImages[pc.HeadImageIndex], ivec2(pc.TargetPx)).r;
    while (idx != INVALID_NODE) {
        const SelectionNode node = SelectionBuffers[pc.SelectionNodesIndex].Nodes[idx];
        const uint write_idx = atomicAdd(ClickResults[pc.ClickResultIndex].Count, 1);
        if (write_idx < MAX_CLICK_RESULTS) {
            ClickResults[pc.ClickResultIndex].Hits[write_idx].Depth = node.Depth;
            ClickResults[pc.ClickResultIndex].Hits[write_idx].ObjectId = node.ObjectId;
        }
        idx = node.Next;
    }
}
