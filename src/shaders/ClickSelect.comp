#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_scalar_block_layout : require

#define GROUP_SIZE 256
layout(local_size_x = GROUP_SIZE) in;

#include "ClickResult.glsl"
#include "ClickSelectPushConstants.glsl"
#include "SelectionNode.glsl"

#define MAX_CLICK_RESULTS 256
const uint INVALID_NODE = 0xffffffffu;

layout(set = 0, binding = BINDING_Image, r32ui) uniform uimage2D HeadImages[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer SelectionNodes {
    SelectionNode Nodes[];
} SelectionBuffers[];

layout(set = 0, binding = BINDING_Buffer, scalar) buffer ClickResultBlock {
    ClickResult Data;
} ClickResults[];

void main() {
    const uint local = gl_LocalInvocationID.x;
    const uint diameter = pc.Radius * 2u + 1u;
    const uint pixel_count = diameter * diameter;
    const ivec2 size = imageSize(HeadImages[pc.HeadImageIndex]);

    for (uint i = local; i < pixel_count; i += GROUP_SIZE) {
        const int dx = int(i % diameter) - int(pc.Radius);
        const int dy = int(i / diameter) - int(pc.Radius);
        const uint dist_sq = uint(dx * dx + dy * dy);
        if (dist_sq > pc.Radius * pc.Radius) continue;
        const ivec2 pixel = ivec2(pc.TargetPx) + ivec2(dx, dy);
        if (pixel.x < 0 || pixel.y < 0 || pixel.x >= size.x || pixel.y >= size.y) continue;

        uint node_idx = imageLoad(HeadImages[pc.HeadImageIndex], pixel).r;
        while (node_idx != INVALID_NODE) {
            const SelectionNode node = SelectionBuffers[pc.SelectionNodesIndex].Nodes[node_idx];
            const uint write_idx = atomicAdd(ClickResults[pc.ClickResultIndex].Data.Count, 1);
            if (write_idx < MAX_CLICK_RESULTS) {
                ClickResults[pc.ClickResultIndex].Data.Hits[write_idx].Depth = node.Depth;
                ClickResults[pc.ClickResultIndex].Data.Hits[write_idx].Id = node.Id;
                ClickResults[pc.ClickResultIndex].Data.Hits[write_idx].DistanceSq = dist_sq;
            }
            node_idx = node.Next;
        }
    }
}
